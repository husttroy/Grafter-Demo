\section{Related Work} 
The most related test reuse technique is Skipper. Skipper copies associated portions of a test suite when developers reuse code~\cite{2013:spe:makady}. It determines relevant test cases and transforms them to fit the target system. Skipper is built on Gilligan~\cite{holmes2007supporting, 2012:tosem:holmes} and requires users to provide a {\em pragmatic reuse plan} to establish the mapping of reused entities (e.g., classes, methods) from the original system to the target system. Skipper assumes that clones are full-feature clones at the level of methods and classes. This requirement makes it difficult to apply Skipper to sub-method level clones found by existing clone detectors. It is infeasible to empirically compare {\grafter} with Skipper due to the requirement of having a reuse plan. %\textemdash rename reused entities as needed, replace references to non-reused entities with {\em holes}, fill in these holes with stub code that mocks the objects and method calls by recording and replaying the execution traces from the original program. 
When the reuse plan is incomplete, the resulting tests produced by Skipper could contain compilation errors and developers must fix them manually.

{\grafter} differs from Skipper in three perspectives. First, {\grafter} supports sub-method level clones without explicit interfaces. Second, {\grafter} does not require a reuse plan but rather leverages the syntactic resemblance between clones to guide the grafting process. Third, Skipper may require manual adjustments to fix compilation errors when the reuse plan is incomplete. In contrast, {\grafter} is fully automated using transplantation rules and data propagation heuristics.